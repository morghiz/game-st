<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Game Soundtrack Player</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="main-content">
      <div class="header">
        <div id="breadcrumbs" class="breadcrumbs">
              <i class="fas fa-home"></i></div>
        <div></div>
      </div>
      <div class="content-area">
        <div id="dynamicContent" class="content-grid">
          <p id="initialMessage">Select a game from the list above.</p>
        </div>
      </div>
      <div class="player-bar">
        <div class="player-left">
          <div class="cover-container">
            <img id="currentTrackCover" src="https://placehold.co/150x150" alt="Album Cover" class="track-cover-small"/>
            <button id="playPauseBtnOverlay" class="play-overlay" disabled title="Play/Pause">
              <i class="fas fa-play"></i>
            </button>
          </div>
          <div id="currentTrackDisplay">
            <p id="playingTrackTitle"><span>Not playing</span></p>
            <p id="playingGameTitle"><span>Select a track</span></p>
          </div>
        </div>
        <div class="player-right">
          <div class="player-controls">
            <button id="playPauseBtn" disabled title="Play/Pause">
              <i class="fas fa-play"></i>
            </button>
            <button id="toggleLoopBtn" disabled title="Toggle Player Loop">
              <i class="fas fa-repeat"></i>
            </button>
            <button id="toggle8bitBtn" class="hidden" disabled title="Toggle 8-bit Mode">
              <i class="fas fa-gamepad"></i>
            </button>
            <button id="toggleWaterBtn" class="hidden" disabled title="Toggle Water Mode">
              <i class="fas fa-water"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
    <script type="module">
      import { MybrPlayer } from "./mybr-player-library.js";
      const mybrPlayer = new MybrPlayer();
      const playPauseBtn = document.getElementById("playPauseBtn");
      const playPauseBtnOverlay = document.getElementById("playPauseBtnOverlay");
      const toggleLoopBtn = document.getElementById("toggleLoopBtn");
      const dynamicContent = document.getElementById("dynamicContent");
      const initialMessage = document.getElementById("initialMessage");
      const breadcrumbs = document.getElementById("breadcrumbs");
      const playingTrackTitle = document.getElementById("playingTrackTitle");
      const playingGameTitle = document.getElementById("playingGameTitle");
      const currentTrackCover = document.getElementById("currentTrackCover");
      let currentData = null;
      let currentSelectedGame = null;
      let currentSelectedTrack = null;
      const AUDIO_BASE_PATH = "./audio/";
      const COVERS_BASE_PATH = "./covers/";
      const DEFAULT_COVER_PLACEHOLDER = "https://placehold.co/150x150";

      function getFlagStateFromLocalStorage(id) {
        const savedState = localStorage.getItem('flagsState');
        if (savedState) {
          try {
            const parsedState = JSON.parse(savedState);
            const flag = parsedState.find(f => f.id === id);
            return flag ? flag.isActive : false;
          } catch (e) {
            console.error("Error parsing flags state from localStorage:", e);
          }
        }
        return false;
      }

      const FLAGS_CONFIG = [
        { id: "8bit", buttonId: "toggle8bitBtn", iconClass: "fas fa-gamepad", isActive: getFlagStateFromLocalStorage("8bit") },
        { id: "water", buttonId: "toggleWaterBtn", iconClass: "fas fa-water", isActive: getFlagStateFromLocalStorage("water") }
      ];

      function saveFlagsState() {
        const state = FLAGS_CONFIG.map(flag => ({ id: flag.id, isActive: flag.isActive }));
        localStorage.setItem('flagsState', JSON.stringify(state));
      }

      FLAGS_CONFIG.forEach(flag => {
        flag.element = document.getElementById(flag.buttonId);
        if (flag.element) {
          flag.element.addEventListener("click", () => {
            const wasActive = flag.isActive;
            // Disattiva tutte le altre flag solo se questa non era già attiva
            FLAGS_CONFIG.forEach(f => f.isActive = false);
            if (!wasActive) {
              flag.isActive = true;
            }
            saveFlagsState();
            updateUI(mybrPlayer.loop);
          });
        }
      });

      function updateUI(playerLoopState) {
        const hasTracks = mybrPlayer.tracks.length > 0;
        playPauseBtn.disabled = !hasTracks;
        playPauseBtnOverlay.disabled = !hasTracks;
        toggleLoopBtn.disabled = !hasTracks;

        let activeFlagId = null;
        FLAGS_CONFIG.forEach(flag => {
          const supportsFlag = currentSelectedTrack && currentSelectedTrack.flags && currentSelectedTrack.flags.includes(flag.id);
          if (flag.element) {
            if (supportsFlag) {
              flag.element.classList.remove("hidden");
              flag.element.disabled = !hasTracks;
              flag.element.style.color = flag.isActive ? "#1DB954" : "#ffffff";
            } else {
              // Se la traccia non supporta la flag, il pulsante è nascosto e disabilitato
              flag.element.classList.add("hidden");
              flag.element.disabled = true;
              // IMPORTANTE: NON modificare flag.isActive qui.
              // Lo stato isActive viene gestito SOLO tramite il click del pulsante.
            }
          }
          if (flag.isActive && supportsFlag) {
            activeFlagId = flag.id;
          }
        });

        // Imposta i volumi delle tracce
        mybrPlayer.setTrackVolume('main', 1); // La traccia principale è sempre a 1 di default
        FLAGS_CONFIG.forEach(flag => mybrPlayer.setTrackVolume(flag.id, 0)); // Tutte le tracce flag a 0

        if (activeFlagId) {
          // Se c'è una flag attiva e supportata dal brano, disattiva la traccia principale
          // e attiva la traccia della flag.
          mybrPlayer.setTrackVolume('main', 0);
          mybrPlayer.setTrackVolume(activeFlagId, 1);
        }

        playPauseBtn.innerHTML = mybrPlayer._isPlaying
          ? '<i class="fas fa-pause"></i>'
          : '<i class="fas fa-play"></i>';
        playPauseBtnOverlay.innerHTML = mybrPlayer._isPlaying
          ? '<i class="fas fa-pause"></i>'
          : '<i class="fas fa-play"></i>';
        toggleLoopBtn.style.color = playerLoopState ? "#1DB954" : "#ffffff";
        
        if (!mybrPlayer._isPlaying && !currentSelectedTrack) {
          currentTrackCover.src = DEFAULT_COVER_PLACEHOLDER;
        }
      }

      mybrPlayer.setStatusCallback((status, playerLoopState) => {
        updateUI(playerLoopState);
      });

      const commonPlayPauseHandler = async () => {
        if (mybrPlayer._isPlaying) {
          mybrPlayer.pause();
        } else {
          try {
            await mybrPlayer.play();
          } catch (e) {
            console.error("Error during playback:", e);
          }
        }
      };
      playPauseBtn.addEventListener("click", commonPlayPauseHandler);
      playPauseBtnOverlay.addEventListener("click", commonPlayPauseHandler);

      toggleLoopBtn.addEventListener("click", () => {
        mybrPlayer.loop = !mybrPlayer.loop;
      });

      mybrPlayer.addEventListener("play", () => {
        updateUI(mybrPlayer.loop);
      });

      mybrPlayer.addEventListener("pause", () => {
        updateUI(mybrPlayer.loop);
      });

      mybrPlayer.addEventListener("ended", () => {
        if (!mybrPlayer.loop) {
          // Quando un brano non in loop finisce, il player si ferma.
          // NON resettare lo stato delle flag qui.
          // Le flag mantengono il loro ultimo stato impostato dall'utente.
          currentSelectedTrack = null; // Il brano corrente è terminato
          updateUI(mybrPlayer.loop); // Aggiorna l'UI (nasconde/disabilita i pulsanti flag se non c'è traccia)
          playingTrackTitle.querySelector('span').textContent = "Not playing";
          playingGameTitle.querySelector('span').textContent = "Select a track";
          checkTextOverflow(playingTrackTitle);
          checkTextOverflow(playingGameTitle);
        }
      });
      mybrPlayer.addEventListener("loadstart", () => {});
      mybrPlayer.addEventListener("canplaythrough", () => {});
      mybrPlayer.addEventListener("error", (e) => {
        console.error("Player: error event - An error occurred", e);
      });

      function checkTextOverflow(parentElement) {
          const textSpan = parentElement.querySelector('span');
          if (textSpan) {
              if (textSpan.offsetParent === null) {
                parentElement.classList.remove('marquee-active');
                textSpan.style.transform = 'translateX(0)';
                return;
              }
              if (textSpan.scrollWidth > parentElement.clientWidth) {
                  parentElement.classList.add('marquee-active');
              } else {
                  parentElement.classList.remove('marquee-active');
                  textSpan.style.transform = 'translateX(0)';
              }
          }
      }

      async function loadSoundtrackData() {
        try {
          const response = await fetch("data.json");
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          currentData = await response.json();
          checkUrlAndNavigate();
        } catch (e) {
          console.error("Failed to load soundtrack data:", e);
          dynamicContent.innerHTML =
            '<p style="color:#ef4444;text-align:center;padding:2.5rem 0;">Error loading data.</p>';
        }
      }

      function generateCoverPath(item, type, gameId = null, categoryPath = []) {
        let pathSegments = [];
        if (gameId) {
            pathSegments.push(gameId);
        }
        if (categoryPath.length > 0) {
            pathSegments.push(...categoryPath);
        }
        if (type === 'game' && item && item.id) {
            return `${COVERS_BASE_PATH}${item.id}.png`;
        }
        return `${COVERS_BASE_PATH}${pathSegments.join("/")}/${item.id}.png`;
      }

      function generateAudioPath(track, gameId, categoryPath = []) {
        let pathSegments = [];
        pathSegments.push(gameId);
        if (categoryPath.length > 0) {
            pathSegments.push(...categoryPath);
        }
        pathSegments.push(track.id);
        return `${AUDIO_BASE_PATH}${pathSegments.join("/")}.mybr`;
      }

      function createContentCard(item, type, gameId = null, categoryPath = [], gameTitle = null) {
        const card = document.createElement("div");
        card.className = "content-card";
        const imageContainer = document.createElement("div");
        imageContainer.className = "image-square-container";
        const img = document.createElement("img");
        const imageSource = generateCoverPath(item, type, gameId, categoryPath);
        img.src = imageSource;
        img.alt = item.title || item.name;
        img.onerror = () => {
          if (gameId) {
            img.src = `${COVERS_BASE_PATH}${gameId}.png`;
            img.onerror = () => (img.src = DEFAULT_COVER_PLACEHOLDER);
          } else {
            img.src = DEFAULT_COVER_PLACEHOLDER;
          }
        };
        imageContainer.appendChild(img);
        card.appendChild(imageContainer);
        const bodyDiv = document.createElement("div");
        bodyDiv.className = "content-card-body";
        const title = document.createElement("p");
        title.className = "title";
        title.textContent = item.title || item.name;
        bodyDiv.appendChild(title);
        if (type === "track" && gameTitle) {
          const subtitle = document.createElement("p");
          subtitle.className = "subtitle";
          subtitle.textContent = gameTitle;
          bodyDiv.appendChild(subtitle);
        }
        card.appendChild(bodyDiv);
        return card;
      }

      function displayGamesAsCards(games) {
        initialMessage.style.display = "none";
        dynamicContent.innerHTML = "";
        games.forEach((game) => {
          const gameCard = createContentCard(game, "game", game.id);
          gameCard.dataset.gameId = game.id;
          gameCard.addEventListener("click", () => {
            clearSelection();
            gameCard.classList.add("selected");
            navigateTo([game.id]);
          });
          dynamicContent.appendChild(gameCard);
        });
      }

      function clearSelection() {
        document
          .querySelectorAll(".content-card.selected")
          .forEach((el) => el.classList.remove("selected"));
      }

      function findItemInStructure(pathSegments) {
        let currentLevel = currentData.games;
        let foundItem = null;
        let currentPathObjects = [];
        let gameIdForAudio = null;
        let categoryPathForAudio = [];

        for (let i = 0; i < pathSegments.length; i++) {
            const segmentId = pathSegments[i];
            let item = null;

            if (i === 0) {
                item = currentLevel.find(g => g.id === segmentId);
                if (item) {
                    gameIdForAudio = item.id;
                    currentSelectedGame = item;
                    currentPathObjects.push({type: "game", object: item});
                    currentLevel = item.categories || item.tracks;
                }
            } else {
                item = currentLevel.find(c => c.id === segmentId);
                if (item) {
                    categoryPathForAudio.push(item.id);
                    currentPathObjects.push({type: "category", object: item});
                    currentLevel = item.categories || item.tracks;
                }
            }

            if (!item) {
                console.error("Item not found in path:", segmentId, "at level:", currentLevel);
                return { item: null, currentContent: null, pathObjects: [], gameId: null, categoryPath: [] };
            }
            foundItem = item;
        }
        return { item: foundItem, currentContent: currentLevel, pathObjects: currentPathObjects, gameId: gameIdForAudio, categoryPath: categoryPathForAudio };
      }

      function renderContent(contentItems, gameId, categoryPath = []) {
        dynamicContent.innerHTML = "";
        if (!contentItems || contentItems.length === 0) {
          dynamicContent.innerHTML =
            '<p style="color:#b3b3b3;text-align:center;padding:2.5rem 0;">No items available.</p>';
          return;
        }

        contentItems.forEach((item) => {
          const cardType = (item.categories || item.tracks) ? "category" : "track";
          const card = createContentCard(
            item,
            cardType,
            gameId,
            categoryPath,
            currentSelectedGame ? currentSelectedGame.title : null
          );

          if (cardType === "category") {
            card.addEventListener("click", () => {
              clearSelection();
              card.classList.add("selected");
              const currentUrlPath = window.location.search.replace('?path=', '').split('/').filter(Boolean);
              const newPath = [...currentUrlPath, item.id];
              navigateTo(newPath);
            });
          } else if (cardType === "track") {
            card.dataset.trackId = item.id;
            card.dataset.mybrFile = generateAudioPath(item, gameId, categoryPath);
            card.addEventListener("click", () =>
              selectTrack(item, currentSelectedGame.title, card)
            );
          }
          dynamicContent.appendChild(card);
        });
      }

      async function selectTrack(track, gameTitle, trackCardElement) {
        mybrPlayer.stop();
        document
          .querySelectorAll(".content-card.selected")
          .forEach((el) => el.classList.remove("selected"));
        trackCardElement.classList.add("selected");
        currentSelectedTrack = track;
        playingTrackTitle.querySelector('span').textContent = track.title;
        playingGameTitle.querySelector('span').textContent = gameTitle || "Unknown Game";
        currentTrackCover.src = trackCardElement.querySelector("img").src;
        
        try {
          mybrPlayer.src = trackCardElement.dataset.mybrFile;
          await mybrPlayer._loadingPromise;
          
          updateUI(mybrPlayer.loop); 
          await mybrPlayer.play();
          checkTextOverflow(playingTrackTitle);
          checkTextOverflow(playingGameTitle);
        } catch (e) {
          console.error("Error loading or playing selected track:", e);
        }
      }

      function updateBreadcrumbs(pathSegments) {
        let breadcrumbsHtml = `<span class="breadcrumb-item" data-path='[]'><i class="fas fa-home"></i></span>`;
        let currentBreadcrumbSegments = [];

        pathSegments.forEach((segmentId, index) => {
            currentBreadcrumbSegments.push(segmentId);
            const { pathObjects } = findItemInStructure(currentBreadcrumbSegments);

            if (pathObjects.length > 0) {
                const currentItem = pathObjects[pathObjects.length - 1].object;
                if (currentItem) {
                    breadcrumbsHtml += ` &gt; <span class="breadcrumb-item" data-path='${JSON.stringify(currentBreadcrumbSegments)}'>${currentItem.title || currentItem.name}</span>`;
                }
            }
        });
        breadcrumbs.innerHTML = breadcrumbsHtml;

        breadcrumbs.querySelectorAll('.breadcrumb-item').forEach(item => {
            item.addEventListener('click', () => {
                const targetPath = JSON.parse(item.dataset.path);
                navigateTo(targetPath);
            });
        });
      }

      function navigateTo(pathSegments) {
        const pathString = pathSegments.join('/');
        const newUrl = pathString ? `?path=${pathString}` : window.location.pathname;

        history.pushState({ path: pathSegments }, "", newUrl);
        renderState(pathSegments);
        updateUI(mybrPlayer.loop);
      }

      function renderState(pathSegments) {
        currentSelectedGame = null;

        if (pathSegments.length === 0) {
            updateBreadcrumbs([]);
            displayGamesAsCards(currentData.games);
            return;
        }

        const { item: lastItem, currentContent, gameId, categoryPath } = findItemInStructure(pathSegments);

        if (!lastItem || !gameId) {
            console.error("Invalid path or game not found in path:", pathSegments);
            updateBreadcrumbs([]);
            displayGamesAsCards(currentData.games);
            return;
        }

        updateBreadcrumbs(pathSegments);

        if (lastItem.tracks && lastItem.tracks.length > 0) {
            renderContent(lastItem.tracks, gameId, categoryPath);
        } else if (lastItem.categories && lastItem.categories.length > 0) {
            renderContent(lastItem.categories, gameId, categoryPath);
        } else if (lastItem.tracks && lastItem.tracks.length === 0) {
            dynamicContent.innerHTML = '<p style="color:#b3b3b3;text-align:center;padding:2.5rem 0;">No tracks available in this category.</p>';
        }
        else if (lastItem.categories && lastItem.categories.length === 0) {
            dynamicContent.innerHTML = '<p style="color:#b3b3b3;text-align:center;padding:2.5rem 0;">No subcategories available here.</p>';
        }
        else {
            console.error("No content (tracks or categories) found at the end of the path:", lastItem);
            dynamicContent.innerHTML = '<p style="color:#b3b3b3;text-align:center;padding:2.5rem 0;">No content available here.</p>';
        }
      }

      function checkUrlAndNavigate() {
          const params = new URLSearchParams(window.location.search);
          const pathParam = params.get("path");

          if (pathParam) {
              const pathSegments = pathParam.split('/').filter(Boolean);
              renderState(pathSegments);
          } else {
              navigateTo([]);
          }
      }

      window.addEventListener("popstate", (event) => {
        if (event.state && event.state.path) {
          renderState(event.state.path);
        } else {
          checkUrlAndNavigate();
        }
        updateUI(mybrPlayer.loop);
      });

      const resizeObserver = new ResizeObserver(entries => {
          for (let entry of entries) {
              if (entry.target.id === 'currentTrackDisplay') {
                  checkTextOverflow(playingTrackTitle);
                  checkTextOverflow(playingGameTitle);
              }
          }
      });
      resizeObserver.observe(document.getElementById('currentTrackDisplay'));


      updateUI(mybrPlayer.loop);
      loadSoundtrackData();
      checkTextOverflow(playingTrackTitle);
      checkTextOverflow(playingGameTitle);
    </script>
  </body>
</html>